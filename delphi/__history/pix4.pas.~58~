unit pix4;

interface

uses
  Windows, Registry, SysUtils, System.Classes, SyncObjs, geradorComandos,
  Vcl.StdCtrls, Log, Pix4Communication;

type

  TPix4 = class

  public
    {public fields}

    {public methods}
    procedure LoadSerialPorts(items: TStrings);
    function OpenSerialPort(const ComPort: string): boolean;
    procedure Disconnect;

    function ObterVersaoFirmware: Integer;
    function ObtemModelo: string;

  private
    {private fields}
    hSerialPort : THandle;

    {private methods}
  end;

implementation

  procedure TPix4.LoadSerialPorts(items: TStrings);
  var
    RegIni: TRegistry;
    AList: TStringList;
    loop: Integer;
  begin
    items.Clear;
    RegIni := TRegistry.Create;
    AList := TStringList.Create; // Move the creation of AList outside the try-finally block
    try
      RegIni.RootKey := HKEY_LOCAL_MACHINE;
      if RegIni.OpenKeyReadOnly('HARDWARE\DEVICEMAP\SERIALCOMM') then // Directly open the required registry key
      begin
        RegIni.GetValueNames(AList);
        for loop := 0 to AList.Count - 1 do
          items.Add(RegIni.ReadString(AList[loop]));
      end;
    finally
      RegIni.Free;
      AList.Free;
    end;
  end;

function TPix4.OpenSerialPort(const ComPort: string): boolean;
var
  dcb: TDCB;
  bytesData: TBytes;
  timeouts: TCommTimeouts;
begin
  // open the serial connection
  hSerialPort := CreateFile(
    PChar(Format('\\.\%s', [ComPort])),
    GENERIC_READ or GENERIC_WRITE,
    0,
    nil,
    OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL,
    0
  );
  if hSerialPort = INVALID_HANDLE_VALUE then
  begin
    writeLogs('Failed to open the serial port. Error: ' + IntToStr(GetLastError));
    result := False;
    exit;
  end;

  // configure the serial port settings
  FillChar(dcb, SizeOf(dcb), 0);
  dcb.DCBlength := SizeOf(dcb);
  if not GetCommState(hSerialPort, dcb) then
  begin
    writeLogs('Failed to retrieve serial port settings. Error: ' + IntToStr(GetLastError));
    CloseHandle(hSerialPort);
    result := False;
    exit;
  end;
  dcb.BaudRate := CBR_9600;
  dcb.ByteSize := 8;
  dcb.Parity := NOPARITY;
  dcb.StopBits := ONESTOPBIT;
  if not SetCommState(hSerialPort, dcb) then
  begin
    writeLogs('Failed to set serial port settings. Error: ' + IntToStr(GetLastError));
    CloseHandle(hSerialPort);
    result := False;
    exit;
  end;

  // set the timeouts for read operations
  FillChar(timeouts, SizeOf(timeouts), 0);
  timeouts.ReadIntervalTimeout := MAXDWORD;
  timeouts.ReadTotalTimeoutMultiplier := 0;
  timeouts.ReadTotalTimeoutConstant := 2000; // set a timeout in milliseconds
  if not SetCommTimeouts(hSerialPort, timeouts) then
  begin
    writeLogs('Failed to set serial port timeouts. Error: ' + IntToStr(GetLastError));
    CloseHandle(hSerialPort);
    result := False;
    exit;
  end;

  result := True;
  //result := OpenPort(hSerialPort, ComPort);
end;

procedure TPix4.Disconnect;
begin
  CloseHandle(hSerialPort);
end;



function TPix4.ObterVersaoFirmware: Integer;
var
  retorno: Boolean;
  data: string;
begin
  retorno := WritePix4(hSerialPort, gerarComandoObterVersaoFirmware);

  if retorno then
  begin
    data := ReadPix4(hSerialPort);
    result := 0;
  end
  else
    Result := -1;
end;

function TPix4.ObtemModelo: string;
var
  retorno: Boolean;
  data: string;
begin
  retorno := WritePix4(hSerialPort, gerarComandoObterVersaoFirmware);

  if retorno then
  begin
    data := ReadPix4(hSerialPort);
    result := data;
  end
  else
    Result := 'erro';
end;

end.
