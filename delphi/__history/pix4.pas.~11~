unit pix4;

interface

uses
  Windows, Registry, SysUtils, System.Classes;

type
  TPix4 = class

  public
    {public fields}
    {public methods}
    procedure LoadSerialPorts(items: TStrings);
    function OpenSerialPort(const PortName: string): THandle;
  private
    {private fields}
    {private methods}

  end;

implementation

  procedure TPix4.LoadSerialPorts(items: TStrings);
  var
    RegIni: TRegistry;
    AList: TStringList;
    loop: Integer;
  begin
    items.Clear;
    RegIni := TRegistry.Create;
    AList := TStringList.Create; // Move the creation of AList outside the try-finally block
    try
      RegIni.RootKey := HKEY_LOCAL_MACHINE;
      if RegIni.OpenKeyReadOnly('HARDWARE\DEVICEMAP\SERIALCOMM') then // Directly open the required registry key
      begin
        RegIni.GetValueNames(AList);
        for loop := 0 to AList.Count - 1 do
          items.Add(RegIni.ReadString(AList[loop]));
      end;
    finally
      RegIni.Free;
      AList.Free;
    end;
  end;

  function TPix4.OpenSerialPort(const PortName: string): THandle;
var
  PortHandle: THandle;
  CommTimeouts: TCommTimeouts;
begin
  PortHandle := CreateFile(PChar(PortName), GENERIC_READ or GENERIC_WRITE, 0, nil, OPEN_EXISTING, 0, 0);
  if PortHandle = INVALID_HANDLE_VALUE then
    RaiseLastOSError;

  // Configure the communication timeouts
  FillChar(CommTimeouts, SizeOf(CommTimeouts), 0);
  CommTimeouts.ReadIntervalTimeout := MAXDWORD;
  CommTimeouts.ReadTotalTimeoutMultiplier := 0;
  CommTimeouts.ReadTotalTimeoutConstant := 0;
  CommTimeouts.WriteTotalTimeoutMultiplier := 0;
  CommTimeouts.WriteTotalTimeoutConstant := 0;
  if not SetCommTimeouts(PortHandle, CommTimeouts) then
  begin
    CloseHandle(PortHandle);
    RaiseLastOSError;
  end;

  Result := PortHandle;
end;


end.
